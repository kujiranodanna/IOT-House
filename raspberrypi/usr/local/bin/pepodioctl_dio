#!/bin/bash
# licence GPLv2 ; this scripts designed by IZAMUKARERA 2011.10.8 update 2018.2.24
# pepodioctl for contorl digital-IN/digital-OUT to ANDDIO
# Input channel A to H ,Output channel I to N
# pepodioctl $1:chno [$2:0 or 1] [$3: time->1 to 65535ms]
#
PATH=$PATH:/usr/local/bin:/usr/local/sbin
if [ $# = 0 ]; then
  echo "usage $0 usage $0 read->chno:0-9 | write->chno:0-5 [DO:0|1] [time->1 to 65535ms]"
  exit -1
fi
DI_ADR="A"
#DIO_DEV="/dev/ttyUSB0"
DI_TTY=ttyS1
#DI_TTY=ttyUSB0
WAIT=10
READTM=10
TRY=30
pid=`echo -en $$`
DIO_DEV="/dev/${DI_TTY}"
ALIAS_DI=/www/remote-hand/tmp/.alias_di
CMD="/www/remote-hand/tmp/dioctl.${pid}"
[ -e "$ALIAS_DI" ] && . "$ALIAS_DI"
[ ! -z "$DI_TTY" ] && DIO_DEV="/dev/"${DI_TTY}
if [ ! -e $DIO_DEV ];then
  echo -en "-1"
  exit -1
fi
LOCKFILE="/var/lock/LCK..${DI_TTY}.dio"
LOCK="/var/lock/LCK..${DI_TTY}"
RETRY=$TRY
while [ -e $LOCK ]
do
  msleep `echo -en  $RANDOM |cut -c 1-2`
  RETRY=$(($RETRY - 1))
  if [ $RETRY = 0 ];then
    echo -en "-1" >/dev/stderr
    exit -1
  fi
done

CMD_DIO="/usr/local/bin/epicon -d 5 -D 5 -ql ${DIO_DEV} -c ${CMD}"
n=$1
if [ "$n" -gt 9 ] || [ "$n" -lt 0 ] || [ -n "$2" -a "$1" -gt 5 ] ;then
  echo "usage $0 read->chno:0-9 | write->chno:0-5 [DO:0|1] [time->1 to 65535ms]"
  exit -1
fi

error(){
  [ -e ${CMD} ] && rm -f ${CMD}
  [ -e ${LOCKFILE} ] && rm -f ${LOCKFILE}
  [ -e ${LOCK} ] && rm -f ${LOCK}
  exit 0
}
trap error SIGHUP SIGTERM SIGQUIT SIGKILL SIGINT SIGCHLD

if [ ! -z $2 ];then
# DIO Output channel address set
  k=0
  for i in I J K L M N
  do
    j[$k]=$i
    k=$[$k+1]
  done
  CH=${j[$n]}
  if [ "$2" = "1" ];then
    DO="H"
    DO_INVERT="L"
  else 
    DO="L"
    DO_INVERT="H"
  fi
  [ ! -z $3 ] && OUTTM=$3 || unset OUTTM
else
# DIO Input channel address set
  unset DO
  k=0
  for i in A B C D E F G H P Q
  do
    j[$k]=$i
    k=$[$k+1]
  done
  CH=${j[$n]}
fi

dio_setup(){
 cat>$CMD<<END
#!/bin/bash
dio_out() {
# dio_out CH DATA
  echo -en "${DI_ADR}\${2}\${1}\${3}\\r"
  if [ \$? != "0" ]; then
    echo -en "-1" >/dev/stderr
    return -1
  fi
}

dio_out_in(){
# dio out after read
  msleep ${READTM}
  read -s -n 3 -t 1 R || R="-1"
  [ \`echo -en \$R | awk '{ printf(length(\$0))}'\` != 3 ] && R="-1"
  if [ \$R != "-1" ];then
    echo -en \$R |awk '{D=substr(\$0,2,1);sub("L","0",D);sub("H","1",D);printf D}'>/dev/stderr
  else
    echo -en "-1" >/dev/stderr
    return -1
  fi
}

dio_in() {
# dio_input CH
  local ch
  ch=\$1
  [ \$1 = "Q" ] && ch=""
  echo -en "${DI_ADR}R\${ch}\\r"
  msleep ${READTM}
  if [ \$1 = "Q" ];then
    read -s -n 5 -t 1 R || R="-1"
    [ \`echo -en \$R | awk '{ printf(length(\$0))}'\` != 5 ] && R="-1"
  else
    read -s -n 3 -t 1 R || R="-1"
    [ \`echo -en \$R | awk '{ printf(length(\$0))}'\` != 3 ] && R="-1"
  fi
  if [ \$R != "-1" ];then
    [ \${1} = "P" ] && echo -en \$R |awk '{D=substr(\$0,2,2);printf D}'>/dev/stderr
    [ \${1} = "Q" ] && echo -en \$R |awk '{D=substr(\$0,2,4);printf D}'>/dev/stderr
    [ \${1} != "P" ] && [ \${1} != "Q" ] && echo -en \$R |awk '{D=substr(\$0,3,1);sub("L","0",D);sub("H","1",D);printf D}'>/dev/stderr
  else
    echo -en "-1" >/dev/stderr
    return -1
  fi
}
END
}

dio_exec(){
# lockfile & DIO command exec
  RETRY=$TRY
  while [ $RETRY != 0 ]
  do
    lockfile -0 -r 1 ${LOCKFILE} >/dev/null 2>&1
    [ $? = 0 ] && break
    msleep `echo -en  $RANDOM |cut -c 1-2`
    RETRY=$(($RETRY - 1))
  done
  if [ $RETRY = 0 ];then
    echo -en "-1" >/dev/stderr
    rm -f $CMD
    return
  else
    echo -en $$ >${LOCKFILE}
    chmod +x $CMD
    $CMD_DIO
    rm -f $CMD
    rm -f ${LOCKFILE}
  fi
}

if [ ! -z $DO ];then
# DIO Ouput mode
  if [ ! -z $OUTTM ];then
    if [ ${OUTTM} -lt 656 ];then
      OUTTM=$(($OUTTM * 100))
      dio_setup
    cat>>$CMD<<END
dio_out ${CH} ${DO} ${OUTTM}
dio_out_in ${CH}
END
      dio_exec
    else
      dio_setup
    cat>>$CMD<<END
dio_out ${CH} ${DO}
END
      dio_exec
      msleep $OUTTM
      dio_setup
      cat>>$CMD<<END
dio_out ${CH} ${DO_INVERT}
msleep $WAIT
dio_out_in ${CH}
END
      dio_exec
    fi
  else
    dio_setup
    cat>>$CMD<<END
dio_out ${CH} ${DO}
msleep $WAIT
dio_out_in ${CH}
END
    dio_exec
  fi
else
# DIO Input mode
  dio_setup
  cat>>$CMD<<END
dio_in ${CH}
END
  dio_exec
  exit 0
fi
