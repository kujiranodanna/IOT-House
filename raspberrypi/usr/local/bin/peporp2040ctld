#!/bin/bash
# The MIT License
# Copyright (c) 2022-2027 Isamu.Yamauchi , 2026.1.23 update 2026.1.26
####################################################################################
# peporp2040ctld
# What's this?
# This is a shell program daemon that sends and receives data on the RP2040.
# The client is the shell program peporp2040ctl.
# This program requires epicon.
# Please install it by following the instructions below.
# https://github.com/kujiranodanna/epicon
#####################################################################################
DIR=/www/remote-hand/tmp
prog=peporp2040ctld
sprog=peporp2040ctl
DIO_DEV=/dev/ttyACM0
EPICON_CMD=${DIR}/${prog}.cmd
RP2040_RD=${DIR}/${prog}.rd
RP2040_SD=${DIR}/${prog}.sd
MYPID=${DIR}/${prog}.pid
SDPID=${DIR}/${sprog}.pid
EPICONPID=${DIR}/${prog}.epicon_pid
if [ ! -e $MYPID ];then
  echo -en $$ >$MYPID
else
  exit
fi

WAIT=1000
sWAIT=50
READTM=4
TRY=3
DATEjitter=2
# RP2040_RD MAX Bytes
READCT=47
CMD_DIO="/usr/local/bin/epicon -ql ${DIO_DEV} -s 19200 -c ${EPICON_CMD}"
error(){
  cPID=$(pgrep epicon)
  while [ ! -z $cPID ];do
    if [ -e $EPICONPID ];then
      kill -HUP $(cat $EPICONPID)
    fi
    msleep 100
    cPID=$(pgrep epicon)
  done
  [ -e $RP2040_RD ] && rm -f $RP2040_RD
  [ -e $RP2040_SD ] && rm -f $RP2040_SD
  [ -e $EPICON_CMD ] && rm -f $EPICON_CMD
  [ -e $MYPID ] && rm -f $MYPID
  [ -e $EPICONPID ] && rm -f $EPICONPID
  exit 0
}
trap error TERM HUP INT QUIT

cat >${EPICON_CMD}<<EOF
#!/bin/bash
[ -e $RP2040_RD ] && rm -f $RP2040_RD
[ -e $EPICONPID ]  && rm -f $EPICONPID
echo -en \$\$ >$EPICONPID
error(){
  [ -e $RP2040_RD ] && rm -f $RP2040_RD
  [ -e $RP2040_SD ] && rm -f $RP2040_SD
  exit 0
}
trap error TERM HUP INT QUIT

rp2040_rdout(){
  [ ! -e $SDPID ] && return
  echo -en "\$1\\n" >$RP2040_RD
  msleep $WAIT
  sdPID=\$(cat $SDPID)
  [ -z \$sdPID ] && return
  kill -USR1 \$sdPID
}

rp2040_dummy_read(){
  echo -en "\\n"
  msleep $sWAIT
  read -s -t $READTM tRD
# RD=\$(mawk '{print \$0;exit}')
}

rp2040_write(){
  local tSD tRCT tRTM
  tSD=\$(echo \$1| mawk '{gsub(" ","",\$0);printf \$0}')
  tRCT=\$(echo \$2| mawk '{gsub(" ","",\$0);printf \$0}')
  tRTM=\$(echo \$3| mawk '{gsub(" ","",\$0);printf \$0}')
  [ -z \$tRCT ] && tRCT=$READCT
  [ -z \$tRTM ] && tRTM=$WAIT
  echo -en "\${tSD}\\n"
  RETRY=$TRY
  while [ \${RETRY} -ne 0 ];do
    retry_time=\`echo -en "\${RANDOM}" |cut -c 1-2\`
    msleep \${tRTM}
    read -s -n \${tRCT} -t ${READTM} RD || RD="-1"
#    RD=\$(mawk '{print \$0;exit}')
     [ \${RD} != "-1" ] && break
    RETRY=\$((\${RETRY} - 1))
    msleep \${retry_time}
  done
  rp2040_dummy_read
  rp2040_rdout \${RD}
}

sigusr1(){
  if [ -e $RP2040_SD ];then
    [ -e $RP2040_RD ] && rm -f $RP2040_RD
    SEND=\$(cat $RP2040_SD)
    SD=\$(echo \$SEND |mawk '{printf \$1}')
    RCT=\$(echo \$SEND |mawk '{printf \$2}')
    RTM=\$(echo \$SEND |mawk '{printf \$3}')
    if [ \$SD = "DUMMY" ];then
      rp2040_dummy_read
      [ -z \$RD ] && RD="-1"
      rp2040_rdout \$RD
    else
      rp2040_write "\$SD" "\$RCT" "\$RTM"
    fi
  fi
}

trap sigusr1 USR1
while true;do
  if [ ! -e $RP2040_SD ];then
    msleep 1000
  fi
  msleep 10
done
EOF
chmod +x ${EPICON_CMD}
${CMD_DIO}
while true;do
  msleep 100
done

